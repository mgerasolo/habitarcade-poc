# HabitArcade - Week 1 MVP Epics (4, 5, 6)

This document contains three Week 1 MVP epics for the HabitArcade POC:
- Epic 4: Time Block Priorities
- Epic 5: Target Line Graph (Weight Tracker)
- Epic 6: Parking Lot

---

## Epic 4: Time Block Priorities

**Priority:** Medium (Week 1 MVP)
**Phase:** 1 - Week 1 MVP

### Epic Goal

Enable focused work sessions by defining time blocks with per-block priority lists and timer functionality. Users can create work categories (e.g., "30 min coding", "20 min house cleaning"), maintain ordered priority lists within each block, and optionally link timer completion to habit tracking.

### Requirements Covered

| Requirement | Description |
|-------------|-------------|
| FR29 | User can create time blocks (categories of focused work) |
| FR30 | User can set duration for each time block |
| FR30a | User can link a time block to an existing habit |
| FR31 | User can create a priority list within each time block |
| FR32 | User can reorder priorities within a time block |
| FR33 | User can start a time block session (focus mode) |
| FR34 | System displays timer countdown during focus mode |
| FR35 | System shows only the current block's priority list during focus mode |
| FR36 | System automatically marks linked habit as complete when time block timer finishes |

### Dependencies

- Database infrastructure (PostgreSQL)
- Dashboard widget system (react-grid-layout)
- Habit system (for habit linking feature)

---

### Story 4.1: TimeBlock Data Model and API

As a developer,
I want a TimeBlock data model and REST API,
So that time blocks can be persisted and managed.

**Acceptance Criteria:**

**Given** the database schema is initialized
**When** the system starts
**Then** the `time_blocks` table exists with columns: `id`, `name`, `duration_minutes`, `linked_habit_id`, `is_active`, `is_deleted`, `deleted_at`, `created_at`, `updated_at`

**Given** a POST request to `/api/time-blocks` with valid data
**When** the request includes `{ name: "Coding", duration_minutes: 30 }`
**Then** a new time block is created and returned with status 201

**Given** a GET request to `/api/time-blocks`
**When** the request is processed
**Then** all non-deleted time blocks are returned

**Given** a PUT request to `/api/time-blocks/:id`
**When** the request includes valid updated data
**Then** the time block is updated and returned

**Given** a DELETE request to `/api/time-blocks/:id`
**When** the request is processed
**Then** the time block is soft-deleted (is_deleted=true, deleted_at set)

**Technical Notes:**
- Use Drizzle ORM for schema definition
- Use Zod for request validation
- `linked_habit_id` is nullable foreign key to habits table
- Follow API response format: `{ data: TimeBlock }` or `{ data: TimeBlock[], count: number }`

---

### Story 4.2: Priority List Per Block

As a user,
I want to maintain an ordered priority list within each time block,
So that I know what to work on when I start a focused session.

**Acceptance Criteria:**

**Given** the database schema is initialized
**When** the system starts
**Then** the `time_block_priorities` table exists with columns: `id`, `time_block_id`, `title`, `sort_order`, `is_deleted`, `deleted_at`, `created_at`, `updated_at`

**Given** a time block exists
**When** I POST to `/api/time-blocks/:id/priorities` with `{ title: "HabitArcade" }`
**Then** a priority item is added with the next available sort_order

**Given** a time block has multiple priorities
**When** I GET `/api/time-blocks/:id/priorities`
**Then** priorities are returned ordered by sort_order ascending

**Given** a time block has priorities [A, B, C]
**When** I PUT to `/api/time-blocks/:id/priorities/reorder` with new order [C, A, B]
**Then** sort_order values are updated to reflect the new order

**Given** a priority item exists
**When** I DELETE `/api/time-blocks/:id/priorities/:priorityId`
**Then** the priority is soft-deleted

**Technical Notes:**
- Use integer `sort_order` for ordering (increment by 10 for gap insertion flexibility)
- Reorder endpoint receives array of priority IDs in desired order
- Return priorities inline with time block when fetching `/api/time-blocks/:id?include=priorities`

---

### Story 4.3: TimeBlocks Widget

As a user,
I want a dashboard widget showing my time blocks,
So that I can see and manage my work categories from the dashboard.

**Acceptance Criteria:**

**Given** I view the dashboard
**When** the TimeBlocks widget is displayed
**Then** I see a list of all my time blocks with name and duration

**Given** the TimeBlocks widget is displayed
**When** I click "Add Block"
**Then** a form appears to create a new time block with name and duration

**Given** I am creating/editing a time block
**When** I click "Link Habit"
**Then** I can select from existing habits to link

**Given** a time block exists
**When** I click on it in the widget
**Then** I see its priority list with reorderable items

**Given** I view a time block's priorities
**When** I drag a priority item
**Then** I can reorder the list and changes persist

**Given** I view a time block
**When** I click "Start"
**Then** the timer component activates for that block

**Technical Notes:**
- Use TanStack Query for data fetching with `['time-blocks']` query key
- Use drag-and-drop library (dnd-kit or similar) for priority reordering
- Widget component location: `client/src/widgets/TimeBlockPriorities/`
- Zustand store for timer state: `useTimerStore`

---

### Story 4.4: Timer Component

As a user,
I want a countdown timer when I start a time block,
So that I can focus for the defined duration.

**Acceptance Criteria:**

**Given** I start a time block with duration 30 minutes
**When** focus mode activates
**Then** I see a timer counting down from 30:00

**Given** the timer is running
**When** I click "Pause"
**Then** the timer pauses and I see a "Resume" button

**Given** the timer is paused
**When** I click "Resume"
**Then** the timer continues from where it paused

**Given** the timer is running or paused
**When** I click "Reset"
**Then** the timer resets to the block's original duration

**Given** the timer is running
**When** the timer reaches 00:00
**Then** I receive a visual/audio notification that time is up

**Given** the timer completes
**When** a habit is linked to the time block
**Then** the linked habit is automatically marked complete for today (Story 4.5)

**Technical Notes:**
- Use Zustand `useTimerStore` for timer state: `{ blockId, timeRemaining, isRunning, isPaused }`
- Timer logic runs client-side with `setInterval`
- Consider `requestAnimationFrame` for smooth countdown display
- Persist timer state to localStorage for page refresh recovery

---

### Story 4.5: Habit Linking (Timer Completion to Habit Complete)

As a user,
I want my linked habit automatically marked complete when my timer finishes,
So that completing focused work sessions tracks my habit progress.

**Acceptance Criteria:**

**Given** a time block is linked to a habit
**When** I view the time block
**Then** I see which habit is linked

**Given** a time block is linked to a habit "30 min on Software Projects"
**When** the timer completes (reaches 00:00)
**Then** the linked habit is automatically marked as "Complete" for today's date

**Given** a time block is NOT linked to any habit
**When** the timer completes
**Then** no habit is marked (timer just ends)

**Given** I complete a linked timer
**When** the habit is already marked for today
**Then** the existing status is preserved (don't overwrite)

**Given** I want to change a time block's linked habit
**When** I edit the time block
**Then** I can select a different habit or remove the link

**Technical Notes:**
- Timer completion triggers mutation to `/api/habits/:id/entries`
- Use day boundary logic (6 AM default) for determining "today"
- Invalidate `['habits']` query key after auto-completion
- Only mark complete if current status is Empty or Pink-Unmarked

---

## Epic 5: Target Line Graph (Weight Tracker)

**Priority:** Medium (Week 1 MVP)
**Phase:** 1 - Week 1 MVP

### Epic Goal

Enable measurement tracking with a visual target line graph. Users can track metrics like weight against a goal line calculated from start value to target value over a defined time period. The graph shows actual progress versus the ideal trajectory.

### Requirements Covered

| Requirement | Description |
|-------------|-------------|
| FR37 | User can create measurements (e.g., weight) with units |
| FR38 | User can log measurement entries with date and value |
| FR39 | User can set target goals (start value, end value, start date, end date) |
| FR40 | System displays target line graph showing progress against goal |
| FR41 | System indicates on-track/off-track status visually |
| FR42 | System displays progress summary (amount changed, amount remaining) |

### Dependencies

- Database infrastructure (PostgreSQL)
- Dashboard widget system (react-grid-layout)
- Apache ECharts for visualization

---

### Story 5.1: Measurement Data Model and API

As a developer,
I want a Measurement data model and REST API,
So that measurements and their entries can be persisted and managed.

**Acceptance Criteria:**

**Given** the database schema is initialized
**When** the system starts
**Then** the `measurements` table exists with columns: `id`, `name`, `unit`, `is_deleted`, `deleted_at`, `created_at`, `updated_at`

**Given** the database schema is initialized
**When** the system starts
**Then** the `measurement_entries` table exists with columns: `id`, `measurement_id`, `date`, `value`, `created_at`, `updated_at`

**Given** a POST request to `/api/measurements` with `{ name: "Weight", unit: "lbs" }`
**When** the request is processed
**Then** a new measurement is created and returned with status 201

**Given** a measurement exists
**When** I POST to `/api/measurements/:id/entries` with `{ date: "2025-01-15", value: 378 }`
**Then** an entry is created for that measurement on that date

**Given** I POST an entry for a date that already has an entry
**When** the request is processed
**Then** the existing entry's value is updated (upsert behavior)

**Given** a GET request to `/api/measurements/:id/entries`
**When** the request includes optional query params `?startDate=&endDate=`
**Then** entries within the date range are returned, ordered by date

**Technical Notes:**
- Use Drizzle ORM for schema definition
- Use Zod for request validation
- `date` should be stored as DATE type (no time component)
- `value` as DECIMAL for precision
- Unique constraint on (measurement_id, date) pair

---

### Story 5.2: Target Configuration (Start, Goal, End Date)

As a user,
I want to configure a target goal for my measurement,
So that I can track progress against a defined trajectory.

**Acceptance Criteria:**

**Given** a measurement exists
**When** I PUT to `/api/measurements/:id` with target config
**Then** I can set `start_value`, `goal_value`, `start_date`, and `end_date`

**Given** I configure a weight target
**When** I set start_value=382, goal_value=320, start_date=2025-01-01, end_date=2025-12-31
**Then** the measurement stores these target parameters

**Given** a measurement has target configuration
**When** I GET `/api/measurements/:id`
**Then** the response includes target parameters

**Given** I GET a measurement with target config
**When** I request calculated data
**Then** the API returns the target line data points (daily expected values)
**And** the formula used is: `target_value = start_value + ((goal_value - start_value) * days_elapsed / total_days)`

**Technical Notes:**
- Add columns to `measurements` table: `start_value`, `goal_value`, `start_date`, `end_date`
- Target calculation endpoint: GET `/api/measurements/:id/target-line`
- Return array of `{ date, expectedValue }` for chart plotting
- All target fields are nullable (measurement can exist without target)

---

### Story 5.3: TargetGraph Widget (ECharts Line Chart)

As a user,
I want a dashboard widget showing my progress against the target line,
So that I can visually see if I'm on track.

**Acceptance Criteria:**

**Given** I view the dashboard
**When** the TargetGraph widget is displayed
**Then** I see a line chart with date on X-axis and value on Y-axis

**Given** a measurement has a target configured
**When** the chart renders
**Then** I see a straight "target line" from start_value at start_date to goal_value at end_date

**Given** a measurement has entries
**When** the chart renders
**Then** I see my actual measurement values plotted as a second line/points

**Given** both lines are displayed
**When** I hover over data points
**Then** I see tooltip with date and value details

**Given** the widget is displayed
**When** the measurement has no target configured
**Then** only the actual values line is shown (no target line)

**Technical Notes:**
- Use Apache ECharts via `echarts-for-react`
- Widget location: `client/src/widgets/TargetLineGraph/`
- TanStack Query key: `['measurements', measurementId, 'entries']`
- Chart should be responsive to widget resize
- Use different colors for target line (dashed gray) vs actual (solid blue/green)

---

### Story 5.4: Measurement Entry Form

As a user,
I want a quick way to add new measurement entries,
So that I can log my daily values with minimal friction.

**Acceptance Criteria:**

**Given** I view the TargetGraph widget
**When** I want to add a new entry
**Then** I see an "Add Entry" button or quick-add form

**Given** I click "Add Entry" or focus the quick-add form
**When** the form appears
**Then** I see fields for date (defaulting to today) and value

**Given** I enter a value and submit
**When** today's date is selected
**Then** the entry is saved and the chart updates immediately

**Given** I already have an entry for today
**When** I submit a new value for today
**Then** today's entry is updated (not duplicated)

**Given** I submit the form
**When** the entry saves successfully
**Then** the form clears and shows success feedback

**Technical Notes:**
- Use React Hook Form for form handling
- Optimistic update via TanStack Query mutation
- Default date to current date considering day boundary (6 AM)
- Numeric input with appropriate step for unit (0.1 for lbs)
- Invalidate `['measurements', id, 'entries']` on success

---

### Story 5.5: Above/Below Target Indication

As a user,
I want to see at a glance whether I'm above or below my target,
So that I know if I need to adjust my efforts.

**Acceptance Criteria:**

**Given** I have a target configured and recent entries
**When** the widget displays
**Then** I see a status indicator showing "On Track", "Above Target", or "Below Target"

**Given** my latest entry is below the expected target value (for weight loss goal)
**When** the indicator displays
**Then** it shows "On Track" with a green/positive indicator

**Given** my latest entry is above the expected target value (for weight loss goal)
**When** the indicator displays
**Then** it shows "Above Target" with a yellow/orange indicator

**Given** I have entries
**When** the widget displays
**Then** I see a progress summary: "[X] lbs lost, [Y] to go" or equivalent

**Given** the chart is displayed
**When** there's a significant variance from target
**Then** the area between actual and target lines is shaded (green if ahead, red if behind)

**Technical Notes:**
- Calculate expected value for latest entry date using target line formula
- Compare actual vs expected: `variance = actual - expected`
- For weight loss: negative variance is good (below target line)
- Invert logic for metrics where higher is better (future consideration)
- Progress summary: `changed = start_value - latest_value`, `remaining = latest_value - goal_value`

---

## Epic 6: Parking Lot

**Priority:** Medium (Week 1 MVP flex / Week 2 fallback)
**Phase:** 1 - Week 1 MVP

### Epic Goal

Provide a quick capture inbox for brain dump items. Users can rapidly log thoughts, tasks, and ideas with minimal friction, then process them later into scheduled tasks or delete them.

### Requirements Covered

| Requirement | Description |
|-------------|-------------|
| FR43 | User can quickly add items to the Parking Lot |
| FR44 | User can view all Parking Lot items |
| FR45 | User can convert Parking Lot items to tasks |
| FR46 | User can delete Parking Lot items |

### Dependencies

- Database infrastructure (PostgreSQL)
- Dashboard widget system (react-grid-layout)
- Task system (for conversion to scheduled tasks)

---

### Story 6.1: ParkingLot Data Model and API

As a developer,
I want a data model and API for Parking Lot items,
So that quick capture items can be persisted.

**Acceptance Criteria:**

**Given** the database schema is initialized
**When** the system starts
**Then** Parking Lot items are stored in the `tasks` table with `planned_date = NULL`

**Given** a POST request to `/api/parking-lot` with `{ title: "Schedule dentist" }`
**When** the request is processed
**Then** a task is created with `planned_date = NULL` and returned with status 201

**Given** a GET request to `/api/parking-lot`
**When** the request is processed
**Then** all non-deleted tasks with `planned_date = NULL` are returned

**Given** a DELETE request to `/api/parking-lot/:id`
**When** the request is processed
**Then** the item is soft-deleted

**Given** a parking lot item exists
**When** I PUT to `/api/parking-lot/:id/schedule` with `{ planned_date: "2025-01-20" }`
**Then** the task's planned_date is updated and it no longer appears in parking lot

**Technical Notes:**
- Parking Lot items ARE tasks - just unscheduled ones (planned_date = NULL)
- No separate table needed; reuse `tasks` table from Epic 2/3
- Dedicated endpoints for parking lot semantics but same underlying model
- Alternative: use existing task endpoints with `?unscheduled=true` filter

---

### Story 6.2: QuickInput Component

As a user,
I want to add items to the Parking Lot with just a keystroke,
So that I can capture thoughts before they're forgotten.

**Acceptance Criteria:**

**Given** I view the ParkingLot widget
**When** the widget renders
**Then** I see a text input field prominently displayed

**Given** the input field is visible
**When** I type text and press Enter
**Then** the item is saved to the Parking Lot immediately

**Given** I submit an item
**When** the save succeeds
**Then** the input field clears and the new item appears in the list

**Given** I submit an empty input
**When** I press Enter
**Then** nothing happens (no empty items created)

**Given** I am typing in the input
**When** I press Escape
**Then** the input clears without saving

**Technical Notes:**
- Auto-focus input when widget is visible (optional, may be disruptive)
- Use uncontrolled input with ref for performance
- TanStack Query mutation with optimistic update
- Mutation key: `['parking-lot', 'create']`
- Invalidate `['parking-lot']` on success

---

### Story 6.3: ParkingLot Widget

As a user,
I want a dashboard widget showing my Parking Lot items,
So that I can see captured items and process them.

**Acceptance Criteria:**

**Given** I view the dashboard
**When** the ParkingLot widget is displayed
**Then** I see the QuickInput at the top and a list of items below

**Given** items exist in the Parking Lot
**When** the list displays
**Then** items are shown in reverse chronological order (newest first)

**Given** the widget displays
**When** I view each item
**Then** I see the item title and a delete button

**Given** the widget is on the dashboard
**When** I want to schedule an item
**Then** I can drag it to a day column in the Weekly Kanban widget

**Given** I drag an item to a day in Weekly Kanban
**When** I drop it
**Then** the item receives that day's date and moves out of the Parking Lot

**Technical Notes:**
- Widget location: `client/src/widgets/ParkingLot/`
- TanStack Query key: `['parking-lot']` or `['tasks', { unscheduled: true }]`
- Use react-grid-layout's drag-out capability or custom drag implementation
- Cross-widget drag requires shared drag context (react-dnd or similar)
- Consider scrollable list if many items accumulate

---

### Story 6.4: Delete Item Functionality

As a user,
I want to delete Parking Lot items,
So that I can remove items that are no longer relevant.

**Acceptance Criteria:**

**Given** an item is displayed in the Parking Lot
**When** I click the delete button
**Then** the item is removed from the list immediately (optimistic)

**Given** I delete an item
**When** the deletion succeeds
**Then** the item is soft-deleted in the database

**Given** I accidentally delete an item
**When** I realize the mistake
**Then** I can restore it from a trash/deleted items view (future consideration)

**Given** I hover over an item
**When** the delete button appears
**Then** it's clearly visible but not disruptive to the list view

**Technical Notes:**
- Use soft delete (is_deleted = true, deleted_at = timestamp)
- TanStack Query optimistic update: remove from cache immediately
- Rollback on error
- Consider "undo" toast notification instead of trash view for MVP
- Delete button can be an "X" icon on hover or always visible

---

## Requirements Coverage Summary

### Epic 4 Coverage (Time Block Priorities)

| Story | Requirements |
|-------|--------------|
| 4.1 TimeBlock Data Model and API | FR29, FR30 |
| 4.2 Priority List Per Block | FR31, FR32 |
| 4.3 TimeBlocks Widget | FR29, FR31, FR32 |
| 4.4 Timer Component | FR33, FR34, FR35 |
| 4.5 Habit Linking | FR30a, FR36 |

### Epic 5 Coverage (Target Line Graph)

| Story | Requirements |
|-------|--------------|
| 5.1 Measurement Data Model and API | FR37, FR38 |
| 5.2 Target Configuration | FR39 |
| 5.3 TargetGraph Widget | FR40 |
| 5.4 Measurement Entry Form | FR38 |
| 5.5 Above/Below Target Indication | FR41, FR42 |

### Epic 6 Coverage (Parking Lot)

| Story | Requirements |
|-------|--------------|
| 6.1 ParkingLot Data Model and API | FR43, FR44, FR45 |
| 6.2 QuickInput Component | FR43 |
| 6.3 ParkingLot Widget | FR44, FR45 |
| 6.4 Delete Item Functionality | FR46 |

---

## Implementation Notes

### Database Schema Additions

**For Epic 4:**
```sql
-- time_blocks table
CREATE TABLE time_blocks (
  id SERIAL PRIMARY KEY,
  name VARCHAR(255) NOT NULL,
  duration_minutes INTEGER NOT NULL,
  linked_habit_id INTEGER REFERENCES habits(id),
  is_active BOOLEAN DEFAULT false,
  is_deleted BOOLEAN DEFAULT false,
  deleted_at TIMESTAMP,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- time_block_priorities table
CREATE TABLE time_block_priorities (
  id SERIAL PRIMARY KEY,
  time_block_id INTEGER NOT NULL REFERENCES time_blocks(id),
  title VARCHAR(255) NOT NULL,
  sort_order INTEGER NOT NULL,
  is_deleted BOOLEAN DEFAULT false,
  deleted_at TIMESTAMP,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);
```

**For Epic 5:**
```sql
-- measurements table
CREATE TABLE measurements (
  id SERIAL PRIMARY KEY,
  name VARCHAR(255) NOT NULL,
  unit VARCHAR(50) NOT NULL,
  start_value DECIMAL,
  goal_value DECIMAL,
  start_date DATE,
  end_date DATE,
  is_deleted BOOLEAN DEFAULT false,
  deleted_at TIMESTAMP,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- measurement_entries table
CREATE TABLE measurement_entries (
  id SERIAL PRIMARY KEY,
  measurement_id INTEGER NOT NULL REFERENCES measurements(id),
  date DATE NOT NULL,
  value DECIMAL NOT NULL,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  UNIQUE(measurement_id, date)
);
```

**For Epic 6:**
```sql
-- No new tables - uses existing tasks table with planned_date = NULL
```

### Shared Dependencies

- All epics depend on the base infrastructure from Epic 1 (Dashboard)
- Epic 4 (Time Blocks) has a soft dependency on Epic 2/3 (Habits) for habit linking
- Epic 6 (Parking Lot) has a soft dependency on Epic 2/3 (Tasks/Kanban) for scheduling integration
